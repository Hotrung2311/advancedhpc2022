# -*- coding: utf-8 -*-
"""GPU_no_share_memory_ver.ipynb

Automatically generated by Colaboratory.

Original file is located at
    https://colab.research.google.com/drive/1aIa1ei2mPOds4KL0T-4HjZL5II6_7Aqu
"""

!git clone https://github.com/Hotrung2311/publicfolder.git

from numba import cuda
import numpy as np
import matplotlib.pyplot as plt
import matplotlib.image as mpimg
import time
import math

root = mpimg.imread('publicfolder/000.png')
imgplot = plt.imshow(root)
plt.show()

@cuda.jit 
def calV(src, dst): 
    tidx = cuda.threadIdx.x + cuda.blockIdx.x * cuda.blockDim.x
    tidy = cuda.threadIdx.y + cuda.blockIdx.y * cuda.blockDim.y

    R = src[tidx, tidy, 2]/255
    G = src[tidx, tidy, 1]/255
    B = src[tidx, tidy, 0]/255
    
    dst[tidx, tidy, 0] = max(R, G, B)

@cuda.jit(device=True)
def calDS(cMat,vMat,fw,a,b,c,d):
  windowSum = 0
  windowSD = 0
  windowColor = 0

  f1 = a
  t1 = b
  f2 = c
  t2 = d
  if a < 0: 
    f1 = 0
  if b > len(cMat)-1:
    t1 = len(cMat)-1
  if c < 0:
    f2 = 0
  if d > len(cMat[0])-1:
    t2 = len(cMat[0])-1

  for i in range(f1,t1+1):
    for j in range(f2,t2+1):
        windowSum += vMat[i][j][0]
        windowColor += cMat[i][j]
  windowMean = windowSum/((fw+1)*(fw+1))

  for i in range(f1,t1+1):
    for j in range(f2,t2+1):
        windowSD += (vMat[i][j][0] - windowMean)*(vMat[i][j][0] - windowMean)/((fw+1)*(fw+1))
        
  result = math.sqrt(windowSD)
  windowMeanColor = windowColor/((fw+1)*(fw+1))
  return result, windowMeanColor

@cuda.jit
def kuwahara(src, dst, w, cmat):
  tidx = cuda.threadIdx.x + cuda.blockIdx.x * cuda.blockDim.x
  tidy = cuda.threadIdx.y + cuda.blockIdx.y * cuda.blockDim.y

  dsA, colorA = calDS(cmat, src, w, tidx - w, tidx, tidy - w, tidy)
  dsB, colorB = calDS(cmat, src, w, tidx, tidx + w, tidy - w, tidy)
  dsC, colorC = calDS(cmat, src, w, tidx - w, tidx, tidy, tidy + w)
  dsD, colorD = calDS(cmat, src, w, tidx, tidx + w, tidy, tidy + w)
        
  minWl = min(dsA, dsB, dsC, dsD)
    
  if minWl == dsA:
    dst[tidx, tidy] = colorA
  if minWl == dsB:
    dst[tidx, tidy] = colorB
  if minWl == dsC:
    dst[tidx, tidy] = colorC
  if minWl == dsD:
    dst[tidx, tidy] = colorD

# Calculate V matrix
img = root.copy()
devdata = cuda.to_device(img)
devOutput = cuda.device_array((img.shape[0], img.shape[1], 1),np.float64)
blockSize = (8,8)
gridSize = (math.ceil(img.shape[0] / blockSize[0]), math.ceil(img.shape[1] / blockSize[1]))
calV[gridSize, blockSize](devdata, devOutput)
v_mat = devOutput.copy_to_host()

# Separate R, G, B channels
blue_channel = np.ascontiguousarray(img[:,:,0])
green_channel = np.ascontiguousarray(img[:,:,1])
red_channel = np.ascontiguousarray(img[:,:,2])

# Calculate new color for each channel
window_size = 3
devdata1 = cuda.to_device(v_mat)
devOutput1 = cuda.device_array((img.shape[0], img.shape[1]),np.float64)

blockSize = (8,8)
gridSize = (math.ceil(img.shape[0] / blockSize[0]), math.ceil(img.shape[1] / blockSize[1]))

rc = cuda.to_device(red_channel)
kuwahara[gridSize, blockSize](devdata1, devOutput1, window_size, rc)
red_mat = devOutput1.copy_to_host()

gc = cuda.to_device(green_channel)
kuwahara[gridSize, blockSize](devdata1, devOutput1, window_size, gc)
green_mat = devOutput1.copy_to_host()

bc = cuda.to_device(blue_channel)
kuwahara[gridSize, blockSize](devdata1, devOutput1, window_size, bc)
blue_mat = devOutput1.copy_to_host()

print(red_mat)

combine_img = np.dstack((blue_mat,green_mat,red_mat))
imgplot = plt.imshow(img)
plt.show()
imgplot = plt.imshow(combine_img)
plt.show()